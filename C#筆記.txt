===================================================================
===================================================================
===================================================================
===================================================================
物件的生命週期
C# 的 CLR（Common Language Runtime） 機制
1. CLR 是什麼？
CLR = Common Language Runtime（共通語言執行環境）
是 .NET Framework / .NET Core / .NET 5+ 的核心執行引擎。
功能就像 一個虛擬機器（VM）+ 執行管理系統，負責執行 C# 程式碼，管理記憶體、型別安全、例外處理、垃圾回收等等。
簡單比喻：CLR 就像「程式的後勤部隊」，幫你管理記憶體、資源和安全，程式不用自己操心細節。

CLR 幫你管理：
記憶體：stack / heap、GC 回收
型別安全：防止非法存取
例外處理
多執行緒
安全性檢查

3. CLR 管理的資源
功能	說明
Garbage Collection (GC)	自動回收 heap 上的物件，不用手動 free/delete
Stack / Heap 管理	分配 stack frame、物件在 heap 上的位置
型別檢查	保證程式不會存取錯誤型別的記憶體
JIT 編譯	IL → 原生機器碼
安全性檢查	防止程式操作危險指標或非法操作
===================================================================
using System;

class MyClass
{
    // 四個 int 欄位
    public int a;
    public int b;
    public int c;
    public int d;

    // 建構子，用來初始化欄位
    public MyClass(int a, int b, int c, int d)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    // 方法：計算四個數字的總和
    public int Sum()
    {
        return a + b + c + d;
    }
}

class Program
{
    static void Main()
    {
        // 建立類別物件
        MyClass obj = new MyClass(1, 2, 3, 4);

        // 使用類別的方法
        Console.WriteLine("Sum = " + obj.Sum());  // 輸出 Sum = 10

        // 直接修改欄位
        obj.a = 10;
        Console.WriteLine("New Sum = " + obj.Sum()); // 輸出 New Sum = 19
    }
}

為甚麼 return a + b + c + d; 這邊的a,b,c... 他會直接認得是class的，而不需要 this.a + this.b...

1. 為什麼可以直接用 a 而不是 this.a
在 C# 裡，如果你在 類別的方法內使用變數名稱，編譯器會按照 以下順序找變數：
方法的區域變數（local variable）
例如 int x = 5; 在方法裡宣告的變數。
方法的參數（parameters）
例如 public void Foo(int x)，x 優先於欄位。
類別的欄位（field）
如果在方法裡找不到 local 變數或參數，會使用類別裡的欄位。
這就是為什麼你可以直接寫：
return a + b + c + d;
編譯器知道 a,b,c,d 是這個類別的欄位。

2. 什麼時候需要用 this.
當 區域變數或參數的名稱與欄位名稱衝突 時，需要用 this 來明確指欄位。
class MyClass
{
    public int a;

    public void SetValue(int a)  // 參數 a 與欄位 a 同名
    {
        a = a;        // ❌ 只改了參數 a，不改欄位
        this.a = a;   // ✅ 明確改欄位 a
    }
}
如果沒有命名衝突，this. 可以省略，C# 會自動解析到欄位。

🔑 小結
沒有衝突 → 可以直接用欄位名稱。
有衝突 → 用 this. 指明是類別欄位。
this 本質上是一個指向 當前物件的參考，在 instance 方法裡隱含存在。
===================================================================
| 特性       	| class（類別）              	| struct（結構體）             
| --------------| --------------------------| ----------------------- 
| 型別       	| 參考型別（Reference Type）  | 值型別（Value Type）         
| 記憶體配置    	| Heap（物件本體在堆上）       | Stack（局部變數在棧上）或內嵌在其他物件中 
| 預設建構子    	| 可以有自訂建構子       		| 沒有無參數建構子（系統自帶預設建構子）     
| 繼承       	| 可以繼承其他類（單一繼承）    	| 不支援繼承（可以實作介面）           
| 釋放記憶體    	| 由 GC（垃圾回收）管理        | 自動隨變數作用域消失              
| 可否為 null 	| 可以，因為是 reference type	| 不可以（值型別）                
===================================================================
物件: 封裝，繼承，多態
===================================================================
在 C# 中，out 和 ref 都是 參考傳遞（pass by reference） 的方式，但它們有一些重要差異。
ref → 已有值，要讓方法修改它。
out → 沒有值，要讓方法提供一個輸出。
===================================================================
out: 可使用便量的地址，而非拷貝
===================================================================
📌 Heap 的釋放時機
這就依語言不同而不同了：

在 C# / Java / Python（有 Garbage Collector, GC）
Heap 上的物件不需要手動釋放。
GC 會自動偵測「不再被任何變數參考的物件」，然後釋放它們。
所以 heap 的釋放時機是 GC 覺得需要回收時（不一定馬上）。
當程式結束時，作業系統一樣會回收整個 process 的記憶體。
===================================================================
📌 Stack 的釋放時機
每個函式呼叫都會在 Stack 上開一塊「stack frame」（儲存區域）。
當函式執行結束，這個 stack frame 自動釋放。
不用程式設計師管，由編譯器/系統自動處理。

👉 範例：
void foo() {
    int x = 10;   // x 在 stack 上
}  // foo 結束 → x 自動消失
===================================================================
1. string 的型別
string fruit = "apple";
fruit 本身是一個變數（存在 stack 上），裡面存的是一個 參考（reference）。
這個參考指向 heap 上的字串物件 "apple"。

2. 不可變性（Immutable）
字串內容一旦建立就不能改變。
當你「改字串」的時候，其實是 建立一個新字串物件，再讓參考指向它。

👉 範例：
string fruit = "apple";
fruit = fruit.ToUpper();   // 不是把 "apple" 變成 "APPLE"
                          // 而是建立一個新的 "APPLE"
Console.WriteLine(fruit); // 輸出 "APPLE"
這裡 "apple" 還在 heap 裡，只是 fruit 變數改指向新的 "APPLE"。

3. 跟陣列（int[]）的差別
陣列 (int[]) 也是 reference type，但它是 可變的（mutable） → 你可以直接改裡面的元素。
字串 (string) 雖然也是 reference type，但它是 不可變的（immutable） → 每次修改都會產生新物件。
===================================================================
static void Main()
{
    int[] arr = { 1, 2, 3, 4, 5 };
    upateArray(arr);
    Console.WriteLine(string.Join(", ", arr));
}

static void upateArray(int[] arr)
{
    for (int i = 0; i < arr.Length; i++)
    {
        arr[i] += 5;
    }
}
為甚麼 arr 改變了?

因為 在 C# 中，陣列是「參考型別（reference type）」。
宣告 int[] arr = { 1, 2, 3, 4, 5 };
Stack：變數 arr（reference，參考）
Heap：真正的陣列物件 [1, 2, 3, 4, 5]

當你呼叫 upateArray(arr)：
參數 arr 傳遞的不是整個陣列的拷貝，而是那個 heap 陣列的「參考」。
所以 upateArray 裡修改 arr[i]，其實就是在改 heap 裡的那個陣列本體。
===================================================================
為什麼需要 Heap
Stack 適合：小型、暫時、作用域清楚的資料。
Heap 適合：大型、動態、跨作用域存活、需要彈性的資料。

⚡一句話：
Stack 是暫存桌子，Heap 是倉庫。
桌子（Stack）上東西拿取快，但空間有限；
倉庫（Heap）空間大、能存久，但要自己整理，動作也比較慢。
===================================================================
struct 是 值型別，用來表示小型、不可變或簡單的資料集合。
class 是 參考型別，適合複雜邏輯、需要繼承、多型的物件導向設計。

class（類別） → 參考型別 (Reference Type)
建立物件時，會放在 Heap（堆積記憶體）。
變數本身存的是「參考 (Reference)」，指向 Heap 的物件。
class Person { public string Name; }
Person p1 = new Person(); // p1 在 Stack，物件在 Heap


struct（結構體） → 值型別 (Value Type)
建立變數時，資料會直接存在 Stack（堆疊記憶體）（或內嵌在其他物件裡）。
複製變數時，會複製整份資料。

棧Stack = 書疊在桌上，你只拿最上面那本 → 速度快、規矩多
堆Heap = 倉庫的大箱子，你可以放任何東西，但找起來比較慢 → 空間大、靈活，但要有人整理

4️⃣ 在 C# 裡的應用
int a = 10; → 存在 Stack
var obj = new MyClass(); → 物件存在 Heap，obj 這個「指標」在 Stack 上

Stack 跟 Heap 都是在 RAM（隨機存取記憶體）上分配空間，只是使用方式不一樣。
差別：
特性			Stack						Heap
位置			RAM 的一小塊固定區域			RAM 的大區域，靈活分配
速度			很快（像疊書）					較慢（要找空位）
管理			自動（進入/離開函式就自動收掉）	需要程式或 GC 幫忙整理
適合存什麼	小變數、函式暫存資料			大物件、陣列、class 物件

所以它們都在記憶體裡，但Stack 是「快速、固定」，Heap 是**「大而彈性，但慢一些」**。
===================================================================
枚舉 → int：允許 (int)myEnum（因為 enum 本質就是 int）
int → 枚舉：必須 (MyEnum)myInt（強制轉型，避免誤用）

📌 例子：
OrderStatus s1 = OrderStatus.Delivered; // 枚舉
int i = (int)s1;                        // enum → int
OrderStatus s2 = (OrderStatus)i;        // int → enum
===================================================================
資料夾	內容								性質			是否要進 Git
bin/	最終輸出（.exe、.dll、pdb、config…）	編譯結果		❌ 忽略
obj/	中繼檔（obj、g.cs、assets.json…）	編譯過程暫存	❌ 忽略

👉 總結：
bin/ 是 最終產物
obj/ 是 過程中產物
兩者都不應該進 Git，只要有 .csproj 與原始碼，其他人就能重新建出來。

原始碼（.cs、.config、.resx）
⬇️ 編譯器 (csc / msbuild)
中繼檔案 → 存放在 obj/ 資料夾
⬇️ 連結 / 輸出
最終輸出 → 存放在 bin/ 資料夾
===================================================================
1. / 除法運算子
如果兩邊都是 整數 (int) → 做「整數除法」，小數點後會被捨棄。
如果其中一邊是 浮點數 (double, float) → 會做「小數除法」。

範例：
int a = 7 / 2;       // = 3   (整數除法，0.5 被捨棄)
double b = 7 / 2.0;  // = 3.5 (浮點數除法)

2. % 取餘數運算子 (modulus, modulo)
用來求「除法的餘數」。
範例：
int c = 7 % 2; // = 1   (7 ÷ 2 = 3 餘 1)
int d = 10 % 3; // = 1  (10 ÷ 3 = 3 餘 1)
===================================================================
使用一個簡單的 do while 去寫 login
public static void Main()
{
	bool result = false;
	do{
		string account = Console.ReadLine();
		string password = Console.ReadLine();
		if (account == "123" && password == "456") {
			Console.WriteLine("Login!");
			result = true;
		} else {
			Console.WriteLine("error!");
		}
	} while (result == false);
	Console.WriteLine("welcome~ welcome!");
}
===================================================================
continue: 立即結束本次循環，開始下一次循環。
===================================================================
在 C# ，switch 的 case 必須接'常量'，且最後必須 break
===================================================================
c#，int a ，string b ...，宣告後一定要給值嗎
變數類型		宣告後必須初始化嗎？	備註
-------------------------------------------------------------
局部變數		✅ 是				使用前必須賦值
成員變數		❌ 不必				有預設值，0 / null / false
靜態變數		❌ 不必				有預設值，0 / null / false
===================================================================
using System;

public class Program
{
    public static void Main()
    {
        try
        {
            string a = "123a";
            int b = int.Parse(a); // 注意 Parse 要大寫 P
        }
        catch (Exception e) // Exception 首字母大寫
        {
            Console.WriteLine(e.Message); // 印出例外訊息
        }
    }
}

1️⃣ e 本身
e 是 Exception 物件
它包含很多屬性和方法：
Message → 例外訊息字串
StackTrace → 呼叫堆疊資訊
InnerException → 內部例外
ToString() → 包含例外類型、訊息、堆疊資訊

如果你寫：Console.WriteLine(e);
實際上會呼叫 e.ToString()
===================================================================
1️⃣ int.TryParse 的行為
int.TryParse(string s, out int result) 做了兩件事：
嘗試把字串 s 轉成整數
如果成功 → result 會被設定成對應整數值，並回傳 true
如果失敗 → result 會被 設定成 0，並回傳 false
===================================================================
整數運算自動提升（integer promotion）
int a = 1;
short b = 2;
Console.WriteLine(a + b); => 3

3️⃣ 往上轉型 vs 往下轉型
轉型方向					自動 / 顯式		風險
小 → 大（short → int）	自動	安全，		無資料丟失
大 → 小（int → short）	顯式 (short)		可能溢位 / 資料丟失
===================================================================
int a = 1;
int b = 2;
Console.WriteLine( (a + b) / 2f); // 2f 強制轉型
=> 1.5
如果兩邊型別不同，C# 會自動往「不會丟失資料」的方向轉型。
常見轉換順序（由低到高）： int → float → double → decimal
===================================================================
C#邏輯口訣: 括號為優先，乘除後加減，比較後邏輯，最後左到右
&& (邏輯 AND) 比 || (邏輯 OR) 優先。 => Console.WriteLine(false || true && true); => true
===================================================================
&& 與 & ，|| 跟 | ，結果相同，但有甚麼區別?
在 C#（還有 Java、C、C++）裡，&& / || 和 & / | 看起來很像，有時候結果一樣，但其實語意不同。
&& 和 || → 邏輯運算子 (Logical operators)
& 和 | → 位元運算子 (Bitwise operators)，但在 C# 裡如果用在 bool 上，也能當 邏輯運算子。
&& 和 || 會「短路」，也就是 一旦結果已經確定，就不會繼續計算右邊
& 和 | 不會短路，兩邊一定都會執行

(B) 位元運算 (Bitwise)
& 和 | 也可以用在整數（int, byte 等），逐位元運算
&& 和 || 只能用在布林運算
int x = 6;   // 二進位 110
int y = 3;   // 二進位 011
Console.WriteLine(x & y);  // 010 → 2
Console.WriteLine(x | y);  // 111 → 7

在 C# 裡：
如果運算子兩邊是 布林值 (bool) → & / | 會被當作 邏輯運算子
如果運算子兩邊是 整數型別 (int, byte, long, …) → & / | 會被當作 位元運算子
換句話說，編譯器根據「運算元的型別」來決定意義。
===================================================================
string person = Console.ReadLine();
Console.WriteLine($"Hello, {(person == "老王" ? "你好" : "流氓")}!");
為甚麼 加了 括號 ( ... ) ，就沒事了?
在 C# 裡，字串插值 $"Hello, { ... }!" 裡面會先計算大括號 { ... } 裡面的 運算式，再把結果轉成字串。
( ... ) 明確告訴編譯器這整段是單一運算式
編譯器先計算括號裡的三元運算子：
person == "老王" ? "你好" : "流氓"
→ 結果是一個字串
然後把結果放進 $"..." 裡面 → 完全沒有歧義
===================================================================
三元運算子的語法：
condition ? value_if_true : value_if_false;
必須有回傳值
===================================================================
1. Unicode？
在電腦早期，不同國家有不同的編碼方式：
美國用 ASCII（7 bit，最多 128 個字元，只能表示英文字母、數字、符號）
台灣常用 BIG5（繁體中文）
日本用 Shift-JIS
大陸用 GB2312/GBK
問題是：👉 同一個二進位數字，在不同編碼系統裡，可能代表完全不同的字！導致「亂碼問題」。

2. Unicode 是什麼？
Unicode 就是為了解決亂碼問題而設計的： 一套 全球統一的字元編碼標準
為世界上每一個文字（不管是英文、中文、日文、韓文、emoji…）分配一個 唯一的編號 (code point)
這個編號通常寫成 U+xxxx（16 進位）

例子：
'A' → U+0041
'中' → U+4E2D
'😃' → U+1F603

3. Unicode 和 char 的關係
在 C#： char 採用 UTF-16 編碼（Unicode 的一種實作方式）
意味著一個 char 固定是 2 byte (16 bit)
可以存一個 Unicode 基本平面 (BMP, U+0000 ~ U+FFFF) 的字元
👉 但超過 U+FFFF 的字（例如 emoji）需要 兩個 char（代理對，surrogate pair） 來表示。

✅ 一句話總結
Unicode 字元就是「全世界所有文字的唯一編號」，每個字都有一個代號（U+xxxx），避免亂碼。
===================================================================
在 C# 中，一個 char 固定佔 2 個 byte (16 bit)，
用的是 UTF-16 編碼，能直接表示大多數常見的 Unicode 字元。
===================================================================
floate的精度 => 7位
小數，默認是double類型，但最常用的是floate
===================================================================
1. bit（位元）
電腦裡最小的資料單位
一個 bit 只能表示 0 或 1
例如：1011 就是 4 個 bit

2. byte（位元組）
1 byte = 8 bit
因為 8 個 bit 可以組合出 2⁸ = 256 種可能（0 ~ 255）
所以一個 byte 能表示 0～255 的數字，或者一個英文字母（ASCII 編碼）
===================================================================
多行註解（加 //） Ctrl+K, Ctrl+C => Ctrl+U(解開)
Ctrl+K => 刪掉該行
===================================================================
傳統寫法
以前寫 C# Console App，你一定要有 class 和 Main() 方法作為程式入口：
using System;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}
這是 完整的「傳統 C# 程式骨架」

2. 簡化寫法（C# 9 / .NET 5 之後）
從 C# 9 開始，可以省略 class Program 和 Main()，直接在檔案最上方寫程式碼：
Console.WriteLine("Hello, World!");
編譯器會自動幫你生成「隱藏的 class 與 Main()」來包住這段程式碼。
這叫 Top-level statements（頂層語句）
目的是 讓初學者更容易上手，不用先理解類別與方法。
===================================================================
C# 編譯 > IL > 打包進 .exe / .dll > 執行 > CLR參戰 > CLR載入IL 
	> JIT把IL轉成機器碼 > CPU執行機器碼
===================================================================