<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle SQL/PL-SQL 重點整理</title>
</head>
<body>
    <h1>Oracle SQL/PL-SQL 重點整理</h1>

    <h2>一、子查詢與運算符</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>關鍵字</th>
            <th>意義</th>
            <th>用法重點</th>
            <th>範例說明</th>
        </tr>
        <tr>
            <td>Subquery</td>
            <td>查詢中的查詢</td>
            <td>可放在 SELECT、WHERE、FROM 中</td>
            <td>找出薪水高於平均者</td>
        </tr>
        <tr>
            <td>ANY / SOME</td>
            <td>任意一個符合即成立</td>
            <td>通常搭配 =, &gt;, &lt;<br>&gt; ANY ≈ &gt; MIN(...)<br>&lt; ANY ≈ &lt; MAX(...)</td>
            <td>薪水高於某部門任意員工</td>
        </tr>
        <tr>
            <td>ALL</td>
            <td>必須全部符合</td>
            <td>通常搭配 =, &gt;, &lt;<br>&gt; ALL ≈ &gt; MAX(...)<br>&lt; ALL ≈ &lt; MIN(...)</td>
            <td>薪水高於某部門所有員工</td>
        </tr>
        <tr>
            <td>EXISTS</td>
            <td>檢查子查詢是否有結果</td>
            <td>通常搭配關聯子查詢<br>只關心「有沒有結果」</td>
            <td>判斷是否是主管</td>
        </tr>
    </table>

    <h2>二、JOIN vs SET OPERATOR 效能比較</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>類型</th>
            <th>處理邏輯</th>
            <th>效能特性</th>
        </tr>
        <tr>
            <td>JOIN</td>
            <td>同時從多張表取資料，依條件比對</td>
            <td>✅ 通常比較快（有索引的話）</td>
        </tr>
        <tr>
            <td>集合查詢 (Set Operator)</td>
            <td>執行多個 SELECT，再合併結果</td>
            <td>⚠️ 通常比較慢（重複掃表 + 合併 + 去重）</td>
        </tr>
    </table>

    <h3>集合查詢效能分析</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>運算子</th>
            <th>效能</th>
            <th>原因說明</th>
        </tr>
        <tr>
            <td>UNION ALL</td>
            <td>✅ 最快</td>
            <td>不做排序、不去重，只單純把結果疊起來</td>
        </tr>
        <tr>
            <td>UNION</td>
            <td>⚠️ 較慢</td>
            <td>需「排序 + 去重」整個結果集</td>
        </tr>
        <tr>
            <td>INTERSECT</td>
            <td>⚠️ 慢</td>
            <td>需「排序 + 比對」兩邊的完整列</td>
        </tr>
        <tr>
            <td>MINUS</td>
            <td>⚠️ 慢</td>
            <td>同樣要排序與比對整列資料</td>
        </tr>
    </table>

    <h3>JOIN 類型效能</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>JOIN 類型</th>
            <th>效能</th>
            <th>特點</th>
        </tr>
        <tr>
            <td>INNER JOIN</td>
            <td>✅ 通常最快</td>
            <td>有索引時最有效率</td>
        </tr>
        <tr>
            <td>LEFT/RIGHT JOIN</td>
            <td>⚠️ 中等</td>
            <td>要保留一邊所有資料</td>
        </tr>
        <tr>
            <td>FULL OUTER JOIN</td>
            <td>❌ 較慢</td>
            <td>兩邊全掃描再合併</td>
        </tr>
        <tr>
            <td>CROSS JOIN</td>
            <td>❌ 非常慢</td>
            <td>產生笛卡兒積（乘法爆炸）</td>
        </tr>
    </table>

    <h2>三、UNKNOWN（三值邏輯）</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>狀態</th>
            <th>意義</th>
        </tr>
        <tr>
            <td>TRUE</td>
            <td>條件為真</td>
        </tr>
        <tr>
            <td>FALSE</td>
            <td>條件為假</td>
        </tr>
        <tr>
            <td>UNKNOWN</td>
            <td>無法判定真或假（通常因為涉及 NULL）</td>
        </tr>
    </table>

    <h3>表達式結果範例</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>表達式</th>
            <th>結果</th>
            <th>原因說明</th>
        </tr>
        <tr>
            <td>5 = 5</td>
            <td>✅ TRUE</td>
            <td>兩邊相同</td>
        </tr>
        <tr>
            <td>5 = 6</td>
            <td>❌ FALSE</td>
            <td>不同</td>
        </tr>
        <tr>
            <td>5 = NULL</td>
            <td>❓ UNKNOWN</td>
            <td>無法判定</td>
        </tr>
        <tr>
            <td>NULL = NULL</td>
            <td>❓ UNKNOWN</td>
            <td>兩個未知值不能確定是否相等</td>
        </tr>
        <tr>
            <td>salary &gt; NULL</td>
            <td>❓ UNKNOWN</td>
            <td>無法比較</td>
        </tr>
        <tr>
            <td>NULL IS NULL</td>
            <td>✅ TRUE</td>
            <td>唯一可確定的 NULL 判斷法</td>
        </tr>
    </table>

    <p><strong>重點：</strong>WHERE 只會選出 TRUE 的資料，FALSE 和 UNKNOWN 都會被排除</p>

    <h2>四、PL/SQL 基礎</h2>
    <h3>PL/SQL 程式結構</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>區塊</th>
            <th>功能</th>
        </tr>
        <tr>
            <td>DECLARE</td>
            <td>宣告變數、常數、游標等（可省略）</td>
        </tr>
        <tr>
            <td>BEGIN ... END;</td>
            <td>程式主要執行區塊</td>
        </tr>
        <tr>
            <td>EXCEPTION</td>
            <td>錯誤發生時的處理（可省略）</td>
        </tr>
    </table>

    <h3>PL/SQL 物件類型</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>類型</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>Procedure（儲存程序）</td>
            <td>執行一段邏輯（不一定回傳值）</td>
        </tr>
        <tr>
            <td>Function（函數）</td>
            <td>執行後回傳一個值</td>
        </tr>
        <tr>
            <td>Trigger（觸發器）</td>
            <td>當事件發生（如 INSERT）自動執行</td>
        </tr>
        <tr>
            <td>Package（套件）</td>
            <td>一組 Procedure + Function 的集合</td>
        </tr>
        <tr>
            <td>Anonymous Block（匿名區塊）</td>
            <td>一次性執行、不儲存的 PL/SQL 區塊</td>
        </tr>
    </table>

    <h3>各資料庫的程式語言</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>資料庫系統</th>
            <th>程式語言名稱</th>
            <th>特性</th>
        </tr>
        <tr>
            <td>Oracle</td>
            <td>PL/SQL</td>
            <td>原始版本，功能最完整</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>SQL/PSM (Stored Program)</td>
            <td>支援 DECLARE、IF、LOOP、CURSOR 等，語法略不同</td>
        </tr>
        <tr>
            <td>PostgreSQL</td>
            <td>PL/pgSQL</td>
            <td>模仿 PL/SQL，功能與 Oracle 類似</td>
        </tr>
        <tr>
            <td>Microsoft SQL Server</td>
            <td>T-SQL (Transact-SQL)</td>
            <td>微軟版本的擴充 SQL，有同樣的流程控制功能</td>
        </tr>
    </table>

    <h2>五、PL/SQL 實務建議</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>類型</th>
            <th>建議實作層</th>
            <th>理由</th>
        </tr>
        <tr>
            <td>商業邏輯（折扣規則、流程判斷）</td>
            <td>✅ 應用程式層</td>
            <td>容易版本控制、可重用、可水平擴充</td>
        </tr>
        <tr>
            <td>資料操作（CRUD、JOIN）</td>
            <td>✅ SQL 查詢層</td>
            <td>資料庫本來就擅長查詢</td>
        </tr>
        <tr>
            <td>批次資料處理、大量更新、彙整</td>
            <td>⚙️ 可考慮 PL/SQL</td>
            <td>減少網路傳輸、效能較好</td>
        </tr>
        <tr>
            <td>系統整體邏輯</td>
            <td>❌ 不建議全寫在資料庫</td>
            <td>維護困難、難以橫向擴展、DevOps 不友好</td>
        </tr>
    </table>

    <h3>產業使用現況</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>產業/系統</th>
            <th>使用狀況</th>
            <th>理由</th>
        </tr>
        <tr>
            <td>銀行、金融</td>
            <td>✅ 高度使用 PL/SQL</td>
            <td>數據安全、交易邏輯封裝於資料庫內部</td>
        </tr>
        <tr>
            <td>政府、傳產 ERP</td>
            <td>⚙️ 中度使用</td>
            <td>舊系統多以 Oracle 為主，重用既有程式</td>
        </tr>
        <tr>
            <td>新創/雲端服務</td>
            <td>🚫 低使用率</td>
            <td>採用微服務架構，邏輯分散在 API 層</td>
        </tr>
        <tr>
            <td>電商、Web App</td>
            <td>🚫 幾乎不用</td>
            <td>改以 Redis / API / ORM 處理邏輯</td>
        </tr>
    </table>

    <h2>六、異常處理（Exception）</h2>
    <h3>異常分類</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>類型</th>
            <th>說明</th>
            <th>範例</th>
            <th>捕捉方式</th>
        </tr>
        <tr>
            <td>程序異常</td>
            <td>由程式邏輯主動觸發，用 RAISE</td>
            <td>RAISE ex_salary_too_low;</td>
            <td>EXCEPTION WHEN ex_salary_too_low THEN ...</td>
        </tr>
        <tr>
            <td>運行異常</td>
            <td>程式執行過程自動發生</td>
            <td>NO_DATA_FOUND、ZERO_DIVIDE</td>
            <td>EXCEPTION WHEN NO_DATA_FOUND THEN ...</td>
        </tr>
    </table>

    <h3>PL/SQL vs 其他語言異常處理</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>PL/SQL</th>
            <th>Java/C#</th>
        </tr>
        <tr>
            <td>BEGIN ... EXCEPTION ... END;</td>
            <td>try { ... } catch { ... }</td>
        </tr>
        <tr>
            <td>RAISE</td>
            <td>throw</td>
        </tr>
        <tr>
            <td>WHEN &lt;exception&gt;</td>
            <td>catch (&lt;exception&gt;)</td>
        </tr>
        <tr>
            <td>WHEN OTHERS</td>
            <td>catch (Exception e)</td>
        </tr>
    </table>

    <h2>七、存儲過程 vs 觸發器</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>特性</th>
            <th>存儲過程 (Procedure)</th>
            <th>觸發器 (Trigger)</th>
        </tr>
        <tr>
            <td>執行方式</td>
            <td>由應用程式或其他程序呼叫</td>
            <td>自動觸發（事件驅動）</td>
        </tr>
        <tr>
            <td>呼叫控制</td>
            <td>可多次呼叫</td>
            <td>無法直接呼叫，依事件發生</td>
        </tr>
        <tr>
            <td>用途</td>
            <td>封裝商業邏輯、批次處理、可重複運算</td>
            <td>強制資料完整性、審計、事件自動處理</td>
        </tr>
        <tr>
            <td>參數</td>
            <td>可以有輸入/輸出參數</td>
            <td>通常用 :NEW / :OLD 讀取資料</td>
        </tr>
        <tr>
            <td>效能</td>
            <td>由使用頻率決定，通常可控</td>
            <td>過多或複雜會降低效能</td>
        </tr>
        <tr>
            <td>可測試性</td>
            <td>容易測試、除錯</td>
            <td>不易測試，需模擬事件</td>
        </tr>
    </table>

    <h3>觸發器觸發事件</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>事件類型</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>INSERT</td>
            <td>當有新資料新增到資料表時觸發</td>
        </tr>
        <tr>
            <td>UPDATE</td>
            <td>當資料表的資料被修改時觸發</td>
        </tr>
        <tr>
            <td>DELETE</td>
            <td>當資料被刪除時觸發</td>
        </tr>
        <tr>
            <td>SELECT</td>
            <td>❌ 不會觸發（只讀取資料不改變資料）</td>
        </tr>
    </table>

    <h3>觸發器使用建議</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>情況</th>
            <th>建議使用觸發器嗎？</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>審計/記錄歷史</td>
            <td>✅ 可以</td>
            <td>例如記錄誰修改了哪筆資料</td>
        </tr>
        <tr>
            <td>資料驗證（簡單檢查）</td>
            <td>⚠️ 小心</td>
            <td>複雜邏輯盡量放應用程式</td>
        </tr>
        <tr>
            <td>批次資料處理</td>
            <td>❌ 不建議</td>
            <td>用單一 SQL / 存儲過程效率高</td>
        </tr>
        <tr>
            <td>核心商業邏輯</td>
            <td>❌ 不建議</td>
            <td>應放在應用層，方便測試與維護</td>
        </tr>
    </table>

    <h2>八、索引（Index）</h2>
    <h3>索引適用情境</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>情境</th>
            <th>建索引建議</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>查詢頻繁的欄位</td>
            <td>✅ 建索引</td>
            <td>用來加速查詢、JOIN、排序、聚合</td>
        </tr>
        <tr>
            <td>高選擇性欄位（值多樣）</td>
            <td>✅ 建索引</td>
            <td>如 employee_id、order_id</td>
        </tr>
        <tr>
            <td>經常更新（UPDATE）的欄位</td>
            <td>❌ 不建索引（或慎用）</td>
            <td>每次更新都要重建或調整索引</td>
        </tr>
        <tr>
            <td>低基數欄位（值少）</td>
            <td>⚠️ 慎用</td>
            <td>如性別（男/女）、狀態（Y/N），B-tree 索引效率低</td>
        </tr>
        <tr>
            <td>極少查詢的欄位</td>
            <td>❌ 不建索引</td>
            <td>不查的欄位建索引是浪費空間</td>
        </tr>
        <tr>
            <td>主鍵、唯一值</td>
            <td>✅ 建索引</td>
            <td>唯一索引自動維護</td>
        </tr>
    </table>

    <h2>九、使用者與權限管理</h2>
    <h3>使用者 vs 角色</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>特性</th>
            <th>使用者（User）</th>
            <th>角色（Role）</th>
        </tr>
        <tr>
            <td>是什麼</td>
            <td>資料庫帳號</td>
            <td>權限集合</td>
        </tr>
        <tr>
            <td>可以登入資料庫嗎</td>
            <td>✅ 可以</td>
            <td>❌ 一般情況不能登入</td>
        </tr>
        <tr>
            <td>擁有物件嗎</td>
            <td>✅ 可以擁有表格、視圖、程序等</td>
            <td>❌ 沒有物件，只存權限</td>
        </tr>
        <tr>
            <td>授權方式</td>
            <td>可直接授權，也可透過角色授權</td>
            <td>將權限授給角色，再授給使用者</td>
        </tr>
        <tr>
            <td>管理方式</td>
            <td>個別管理帳號和權限</td>
            <td>集中管理權限，方便多帳號授權</td>
        </tr>
    </table>

    <h3>Profile（資源配置）</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>參數類型</th>
            <th>參數名稱</th>
            <th>說明</th>
        </tr>
        <tr>
            <td rowspan="7">資源限制</td>
            <td>SESSIONS_PER_USER</td>
            <td>同時允許登入的會話數量</td>
        </tr>
        <tr>
            <td>CPU_PER_SESSION</td>
            <td>單個會話最多使用的 CPU 時間（秒）</td>
        </tr>
        <tr>
            <td>CPU_PER_CALL</td>
            <td>單次 SQL 執行最多使用 CPU 時間</td>
        </tr>
        <tr>
            <td>CONNECT_TIME</td>
            <td>單次連線允許的最長時間（分鐘）</td>
        </tr>
        <tr>
            <td>IDLE_TIME</td>
            <td>連線空閒時間限制（分鐘）</td>
        </tr>
        <tr>
            <td>LOGICAL_READS_PER_SESSION</td>
            <td>單次會話可讀取的邏輯資料塊數量</td>
        </tr>
        <tr>
            <td>PRIVATE_SGA</td>
            <td>每個使用者可使用的 SGA 資源大小（KB）</td>
        </tr>
        <tr>
            <td rowspan="6">密碼策略</td>
            <td>PASSWORD_LIFE_TIME</td>
            <td>密碼有效期（天）</td>
        </tr>
        <tr>
            <td>PASSWORD_GRACE_TIME</td>
            <td>密碼過期後寬限天數</td>
        </tr>
        <tr>
            <td>PASSWORD_REUSE_TIME</td>
            <td>密碼多久不能重複使用（天）</td>
        </tr>
        <tr>
            <td>PASSWORD_REUSE_MAX</td>
            <td>密碼最多能重複使用次數</td>
        </tr>
        <tr>
            <td>FAILED_LOGIN_ATTEMPTS</td>
            <td>登入失敗次數限制</td>
        </tr>
        <tr>
            <td>PASSWORD_LOCK_TIME</td>
            <td>密碼鎖定時間（分鐘/天）</td>
        </tr>
    </table>

    <h3>查詢 Profile 資訊</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>查詢目的</th>
            <th>SQL 語句</th>
        </tr>
        <tr>
            <td>查看使用者所屬 Profile</td>
            <td>SELECT username, profile FROM dba_users WHERE username = 'APP_USER';</td>
        </tr>
        <tr>
            <td>查看 Profile 資源限制</td>
            <td>SELECT * FROM dba_profiles WHERE profile = 'APP_PROFILE';</td>
        </tr>
    </table>

    <h2>十、事務與鎖</h2>
    <h3>ACID 特性</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>特性</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>Atomicity（原子性）</td>
            <td>全部成功或全部失敗</td>
        </tr>
        <tr>
            <td>Consistency（一致性）</td>
            <td>資料庫從一個一致狀態轉換到另一個一致狀態</td>
        </tr>
        <tr>
            <td>Isolation（隔離性）</td>
            <td>同時多個事務不會互相干擾</td>
        </tr>
        <tr>
            <td>Durability（持久性）</td>
            <td>提交後資料不會消失</td>
        </tr>
    </table>

    <h3>鎖的類型</h3>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>類型</th>
            <th>作用</th>
            <th>同時可持有</th>
            <th>可更新資料</th>
            <th>說明</th>
        </tr>
        <tr>
            <td>共享鎖 (S Lock)</td>
            <td>保護資料被讀取</td>
            <td>✅ 多個 session</td>
            <td>❌ 不能修改</td>
            <td>允許多個使用者同時讀取資料，但不能修改（讀鎖）</td>
        </tr>
        <tr>
            <td>獨佔鎖 (X Lock)</td>
            <td>保護資料被修改</td>
            <td>❌ 一個 session</td>
            <td>✅ 可以修改</td>
            <td>持有者可以修改資料，其他人不能讀也不能改（寫鎖）<br>Oracle 自動加在 DML 操作上</td>
        </tr>
        <tr>
            <td>死鎖 (Deadlock)</td>
            <td>互相等待鎖，無法前進</td>
            <td>❌ -</td>
            <td>❌ -</td>
            <td>兩個或以上的 session 互相等待對方釋放鎖<br>Oracle 會自動偵測並終止其中一個 session</td>
        </tr>
    </table>

    <h3>避免死鎖建議</h3>
    <ul>
        <li>盡量保持修改資料的順序一致</li>
        <li>避免長時間持鎖</li>
        <li>讀取資料用快照隔離（READ COMMITTED 或 SERIALIZABLE）</li>
    </ul>

    <h2>十一、重要概念總結</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>概念</th>
            <th>重點說明</th>
        </tr>
        <tr>
            <td>JOIN vs SET OPERATOR</td>
            <td>JOIN 把表連起來（關係型）；SET OPERATOR 把查詢疊起來（結果型）<br>JOIN 通常效能更好（有索引時）</td>
        </tr>
        <tr>
            <td>UNKNOWN</td>
            <td>SQL 是三值邏輯（TRUE/FALSE/UNKNOWN）<br>比較中有 NULL → 結果是 UNKNOWN<br>WHERE 只選出 TRUE，UNKNOWN 會被排除</td>
        </tr>
        <tr>
            <td>PL/SQL</td>
            <td>Oracle 的「可編程 SQL」語言<br>用來在資料庫內寫流程控制、封裝商業邏輯、觸發事件<br>不是用來取代程式邏輯，而是「輔助資料處理」</td>
        </tr>
        <tr>
            <td>存儲過程</td>
            <td>需明確呼叫，用於封裝邏輯、批次處理<br>容易測試、除錯</td>
        </tr>
        <tr>
            <td>觸發器</td>
            <td>自動觸發（事件驅動），無法直接呼叫<br>用於資料完整性、審計<br>業界不建議濫用（維護困難、效能影響）</td>
        </tr>
        <tr>
            <td>索引</td>
            <td>為「查詢」加速設計的，不是為「寫入」優化<br>常查詢、高選擇性欄位適合建索引<br>經常更新、低基數欄位不適合</td>
        </tr>
        <tr>
            <td>使用者與角色</td>
            <td>使用者 = 帳號；角色 = 權限包<br>用角色集中管理權限，方便多帳號授權</td>
        </tr>
        <tr>
            <td>Profile</td>
            <td>使用者的資源/安全設定<br>控制資源限制（CPU、會話、連線時間）和密碼策略</td>
        </tr>
        <tr>
            <td>事務</td>
            <td>一組 SQL 操作，要麼全部成功，要麼全部失敗<br>遵循 ACID 特性<br>用 COMMIT 提交，ROLLBACK 回滾</td>
        </tr>
        <tr>
            <td>鎖</td>
            <td>控制同時存取資料的機制<br>共享鎖（多人可讀）、獨佔鎖（一人可寫）、死鎖（互相等待）</td>
        </tr>
    </table>

    <h2>十二、效能優化重點</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>項目</th>
            <th>建議</th>
        </tr>
        <tr>
            <td>索引</td>
            <td>JOIN 條件欄位若有索引會非常快<br>若沒有索引，JOIN 可能反而比集合查詢慢</td>
        </tr>
        <tr>
            <td>UNION vs UNION ALL</td>
            <td>若不需要去重，用 UNION ALL 效能好 5～10 倍</td>
        </tr>
        <tr>
            <td>避免 MINUS / INTERSECT</td>
            <td>可改寫為 LEFT JOIN + IS NULL 或 INNER JOIN，效能更高</td>
        </tr>
        <tr>
            <td>PL/SQL 使用時機</td>
            <td>適合批次型任務（大量資料處理）<br>不適合業務邏輯（應放應用層）</td>
        </tr>
        <tr>
            <td>觸發器</td>
            <td>FOR EACH ROW 對大量資料會大幅拖慢效能<br>避免過多或複雜的觸發器</td>
        </tr>
    </table>

    <h2>十三、SQL 查詢檢查項目</h2>
    <table border="1" cellpadding="8" cellspacing="0">
        <tr>
            <th>檢查項目</th>
            <th>方法</th>
        </tr>
        <tr>
            <td>UPDATE 是否成功</td>
            <td>用 SQL%ROWCOUNT 查看影響的行數<br>或程式語言對應 API（如 JDBC 的 executeUpdate()）</td>
        </tr>
        <tr>
            <td>NULL 值處理</td>
            <td>用 IS NULL 或 IS NOT NULL<br>用 NVL / COALESCE 將 NULL 轉換成具體值</td>
        </tr>
        <tr>
            <td>查看使用者 Profile</td>
            <td>SELECT username, profile FROM dba_users</td>
        </tr>
        <tr>
            <td>查看 Profile 設定</td>
            <td>SELECT * FROM dba_profiles WHERE profile = 'PROFILE_NAME'</td>
        </tr>
    </table>

</body>
</html>