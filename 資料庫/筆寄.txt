🧩 一、子查詢（Subquery）

子查詢就是「查詢中的查詢」，它出現在 SELECT、WHERE 或 FROM 子句裡，用來提供另一個查詢的結果。
最常見的用途：

找出「相對於另一個資料表」的資料。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > (
  SELECT AVG(salary)
  FROM employees
);


👉 說明：
這裡的括號內是子查詢，它先算出平均薪水，再由外層查出「薪水高於平均」的員工。

🔹 二、ANY（或 SOME）

ANY 表示：只要子查詢的結果中，有任意一個值滿足條件，就成立。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > ANY (
  SELECT salary
  FROM employees
  WHERE department_id = 10
);


👉 說明：

子查詢會先找出部門 10 所有員工的薪水。

外層查詢會找出「薪水比部門 10 的 任何一個人高」的員工。
（實際上只要比部門 10 中最小的薪水高，就會被選中。）

🧠 小技巧：

> ANY ≈ > MIN(...)

< ANY ≈ < MAX(...)

🔸 三、ALL

ALL 表示：必須滿足子查詢中「所有值」的條件才成立。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > ALL (
  SELECT salary
  FROM employees
  WHERE department_id = 10
);


👉 說明：

子查詢會先列出部門 10 的所有薪水。

外層查出「薪水比部門 10 所有員工都高」的員工。

🧠 小技巧：

> ALL ≈ > MAX(...)

< ALL ≈ < MIN(...)

🔹 四、EXISTS

EXISTS 表示：子查詢有返回至少一筆資料，就為真 (TRUE)。
它通常搭配相關子查詢（correlated subquery）使用。

📘 範例
SELECT name
FROM employees e
WHERE EXISTS (
  SELECT 1
  FROM departments d
  WHERE d.manager_id = e.employee_id
);


👉 說明：

子查詢會檢查該員工是否是某個部門的主管。

若存在至少一筆符合的紀錄，EXISTS 為 TRUE，該員工就會被選出。

🧠 小技巧：

EXISTS 只關心「有沒有結果」，不管子查詢 SELECT 什麼。

常用來測試「關聯是否存在」。

📊 總結比較表
關鍵字	意義	用法重點	範例說明
Subquery	查詢中的查詢	可放在 SELECT、WHERE、FROM 中	找出薪水高於平均者
ANY / SOME	任意一個符合即成立	通常搭配 =, >, <	薪水高於某部門任意員工
ALL	必須全部符合	通常搭配 =, >, <	薪水高於某部門所有員工
EXISTS	檢查子查詢是否有結果	通常搭配關聯子查詢	判斷是否是主管


JOIN →「把表連起來」
👉 關係型（關鍵字是 ON 或 WHERE）

SET OPERATOR →「把查詢疊起來」
👉 結果型（每個 SELECT 都獨立執行）

⚙️ 一、概念比較：效能差在哪裡？
類型	處理邏輯	效能特性
JOIN	同時從多張表取資料，依照條件比對	✅ 通常比較快（有索引的話）
集合查詢 (Set Operator)	執行多個 SELECT，再合併結果	⚠️ 通常比較慢（要重複掃表 + 合併 + 去重）
🧩 二、每種集合查詢的效能分析
運算子	效能	原因說明
UNION ALL	✅ 最快	不做排序、不去重，只單純把結果疊起來
UNION	⚠️ 較慢	需「排序 + 去重」整個結果集
INTERSECT	⚠️ 慢	需「排序 + 比對」兩邊的完整列
MINUS	⚠️ 慢	同樣要排序與比對整列資料
🔗 三、JOIN 的效能特性
JOIN 類型	效能	特點
INNER JOIN	✅ 通常最快	有索引時最有效率
LEFT JOIN / RIGHT JOIN	⚠️ 中等	因為要保留一邊所有資料
FULL OUTER JOIN	❌ 較慢	等於兩邊全掃描再合併
CROSS JOIN	❌ 非常慢	產生笛卡兒積（乘法爆炸）

📈 六、效能優化重點

索引（Index）是關鍵

JOIN 條件欄位若有索引，會非常快。

若沒有索引，JOIN 可能反而比集合查詢慢。

UNION vs UNION ALL

若不需要去重，用 UNION ALL 效能好 5～10 倍。

避免 MINUS / INTERSECT

可改寫為 LEFT JOIN + IS NULL 或 INNER JOIN，效能更高。

JOIN 比集合查詢更有效率（尤其有索引時）
🔹 UNION ALL 是集合查詢中最快的選項
🔹 MINUS / INTERSECT 最耗效能，建議改寫 JOIN

你提到的 UNKNOWN（未知值），是 SQL 中邏輯判斷（Boolean logic） 的重要概念之一。
它代表「不是 TRUE，也不是 FALSE，而是無法確定的狀態」。
這個概念跟 NULL 密切相關。

🧩 一、UNKNOWN 是什麼？

在 SQL（包括 Oracle）裡，邏輯判斷有三種可能結果：

狀態	意義
TRUE	條件為真
FALSE	條件為假
UNKNOWN	無法判定真或假（通常因為涉及 NULL）

👉 所以 SQL 是「三值邏輯（Three-valued logic）」，不是單純的真/假二值。

🧠 二、為什麼會出現 UNKNOWN？

最常見的情況：當比較運算式中出現 NULL。

例如：

SELECT *
FROM employees
WHERE salary > NULL;


💬 salary > NULL 的結果是什麼？
👉 答案是：UNKNOWN，因為 NULL 代表「不知道是什麼值」，所以沒辦法確定它是否大於。

📊 三、實際例子對照
表達式	結果	原因說明
5 = 5	✅ TRUE	兩邊相同
5 = 6	❌ FALSE	不同
5 = NULL	❓ UNKNOWN	無法判定
NULL = NULL	❓ UNKNOWN	因為兩個未知值不能確定是否相等
salary > NULL	❓ UNKNOWN	無法比較
NULL IS NULL	✅ TRUE	這是唯一可確定的 NULL 判斷法
⚙️ 四、WHERE 子句中的影響

SQL 的 WHERE 子句只會選出 條件為 TRUE 的資料，
FALSE 和 UNKNOWN 都會被排除。

例如：

SELECT * FROM employees WHERE salary > NULL;


👉 結果：沒有任何列被選出。

因為 salary > NULL → UNKNOWN，而 UNKNOWN 不會被當作 TRUE。

🧩 五、如何正確處理 UNKNOWN / NULL

可以用 IS NULL 或 IS NOT NULL 來檢查：

SELECT * FROM employees WHERE salary IS NULL;
SELECT * FROM employees WHERE salary IS NOT NULL;

🧮 六、三值邏輯表（Truth Table）
A	B	A = B	說明
TRUE	TRUE	TRUE	一樣
TRUE	FALSE	FALSE	不一樣
TRUE	UNKNOWN	UNKNOWN	無法判斷
FALSE	UNKNOWN	UNKNOWN	無法判斷
UNKNOWN	UNKNOWN	UNKNOWN	無法判斷
💡 七、小重點整理
重點	說明
UNKNOWN ≠ NULL	UNKNOWN 是邏輯結果，NULL 是資料值
比較中有 NULL → 結果是 UNKNOWN	除非用 IS NULL
WHERE 只會選出 TRUE	FALSE 和 UNKNOWN 都被排除
NULL = NULL 不是 TRUE	需要用 IS NULL 才能判定
🧭 八、延伸：用 NVL / COALESCE 避免 UNKNOWN

你可以用函數將 NULL 轉換成具體值：

SELECT NVL(salary, 0) FROM employees;


這樣比較運算就不會出現 UNKNOWN。

✅ 結論一句話：

UNKNOWN 是 SQL 在比較運算中，遇到 NULL 時產生的「無法判定」結果。
它不是錯誤，而是代表「不知道真或假」，
而在 WHERE 裡，它的效果等於「被忽略」。