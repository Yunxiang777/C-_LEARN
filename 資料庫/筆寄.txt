🧩 一、子查詢（Subquery）

子查詢就是「查詢中的查詢」，它出現在 SELECT、WHERE 或 FROM 子句裡，用來提供另一個查詢的結果。
最常見的用途：

找出「相對於另一個資料表」的資料。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > (
  SELECT AVG(salary)
  FROM employees
);


👉 說明：
這裡的括號內是子查詢，它先算出平均薪水，再由外層查出「薪水高於平均」的員工。

🔹 二、ANY（或 SOME）

ANY 表示：只要子查詢的結果中，有任意一個值滿足條件，就成立。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > ANY (
  SELECT salary
  FROM employees
  WHERE department_id = 10
);


👉 說明：

子查詢會先找出部門 10 所有員工的薪水。

外層查詢會找出「薪水比部門 10 的 任何一個人高」的員工。
（實際上只要比部門 10 中最小的薪水高，就會被選中。）

🧠 小技巧：

> ANY ≈ > MIN(...)

< ANY ≈ < MAX(...)

🔸 三、ALL

ALL 表示：必須滿足子查詢中「所有值」的條件才成立。

📘 範例
SELECT name, salary
FROM employees
WHERE salary > ALL (
  SELECT salary
  FROM employees
  WHERE department_id = 10
);


👉 說明：

子查詢會先列出部門 10 的所有薪水。

外層查出「薪水比部門 10 所有員工都高」的員工。

🧠 小技巧：

> ALL ≈ > MAX(...)

< ALL ≈ < MIN(...)

🔹 四、EXISTS

EXISTS 表示：子查詢有返回至少一筆資料，就為真 (TRUE)。
它通常搭配相關子查詢（correlated subquery）使用。

📘 範例
SELECT name
FROM employees e
WHERE EXISTS (
  SELECT 1
  FROM departments d
  WHERE d.manager_id = e.employee_id
);


👉 說明：

子查詢會檢查該員工是否是某個部門的主管。

若存在至少一筆符合的紀錄，EXISTS 為 TRUE，該員工就會被選出。

🧠 小技巧：

EXISTS 只關心「有沒有結果」，不管子查詢 SELECT 什麼。

常用來測試「關聯是否存在」。

📊 總結比較表
關鍵字	意義	用法重點	範例說明
Subquery	查詢中的查詢	可放在 SELECT、WHERE、FROM 中	找出薪水高於平均者
ANY / SOME	任意一個符合即成立	通常搭配 =, >, <	薪水高於某部門任意員工
ALL	必須全部符合	通常搭配 =, >, <	薪水高於某部門所有員工
EXISTS	檢查子查詢是否有結果	通常搭配關聯子查詢	判斷是否是主管


JOIN →「把表連起來」
👉 關係型（關鍵字是 ON 或 WHERE）

SET OPERATOR →「把查詢疊起來」
👉 結果型（每個 SELECT 都獨立執行）

⚙️ 一、概念比較：效能差在哪裡？
類型	處理邏輯	效能特性
JOIN	同時從多張表取資料，依照條件比對	✅ 通常比較快（有索引的話）
集合查詢 (Set Operator)	執行多個 SELECT，再合併結果	⚠️ 通常比較慢（要重複掃表 + 合併 + 去重）
🧩 二、每種集合查詢的效能分析
運算子	效能	原因說明
UNION ALL	✅ 最快	不做排序、不去重，只單純把結果疊起來
UNION	⚠️ 較慢	需「排序 + 去重」整個結果集
INTERSECT	⚠️ 慢	需「排序 + 比對」兩邊的完整列
MINUS	⚠️ 慢	同樣要排序與比對整列資料
🔗 三、JOIN 的效能特性
JOIN 類型	效能	特點
INNER JOIN	✅ 通常最快	有索引時最有效率
LEFT JOIN / RIGHT JOIN	⚠️ 中等	因為要保留一邊所有資料
FULL OUTER JOIN	❌ 較慢	等於兩邊全掃描再合併
CROSS JOIN	❌ 非常慢	產生笛卡兒積（乘法爆炸）

📈 六、效能優化重點

索引（Index）是關鍵

JOIN 條件欄位若有索引，會非常快。

若沒有索引，JOIN 可能反而比集合查詢慢。

UNION vs UNION ALL

若不需要去重，用 UNION ALL 效能好 5～10 倍。

避免 MINUS / INTERSECT

可改寫為 LEFT JOIN + IS NULL 或 INNER JOIN，效能更高。

JOIN 比集合查詢更有效率（尤其有索引時）
🔹 UNION ALL 是集合查詢中最快的選項
🔹 MINUS / INTERSECT 最耗效能，建議改寫 JOIN

你提到的 UNKNOWN（未知值），是 SQL 中邏輯判斷（Boolean logic） 的重要概念之一。
它代表「不是 TRUE，也不是 FALSE，而是無法確定的狀態」。
這個概念跟 NULL 密切相關。

🧩 一、UNKNOWN 是什麼？

在 SQL（包括 Oracle）裡，邏輯判斷有三種可能結果：

狀態	意義
TRUE	條件為真
FALSE	條件為假
UNKNOWN	無法判定真或假（通常因為涉及 NULL）

👉 所以 SQL 是「三值邏輯（Three-valued logic）」，不是單純的真/假二值。

🧠 二、為什麼會出現 UNKNOWN？

最常見的情況：當比較運算式中出現 NULL。

例如：

SELECT *
FROM employees
WHERE salary > NULL;


💬 salary > NULL 的結果是什麼？
👉 答案是：UNKNOWN，因為 NULL 代表「不知道是什麼值」，所以沒辦法確定它是否大於。

📊 三、實際例子對照
表達式	結果	原因說明
5 = 5	✅ TRUE	兩邊相同
5 = 6	❌ FALSE	不同
5 = NULL	❓ UNKNOWN	無法判定
NULL = NULL	❓ UNKNOWN	因為兩個未知值不能確定是否相等
salary > NULL	❓ UNKNOWN	無法比較
NULL IS NULL	✅ TRUE	這是唯一可確定的 NULL 判斷法
⚙️ 四、WHERE 子句中的影響

SQL 的 WHERE 子句只會選出 條件為 TRUE 的資料，
FALSE 和 UNKNOWN 都會被排除。

例如：

SELECT * FROM employees WHERE salary > NULL;


👉 結果：沒有任何列被選出。

因為 salary > NULL → UNKNOWN，而 UNKNOWN 不會被當作 TRUE。

🧩 五、如何正確處理 UNKNOWN / NULL

可以用 IS NULL 或 IS NOT NULL 來檢查：

SELECT * FROM employees WHERE salary IS NULL;
SELECT * FROM employees WHERE salary IS NOT NULL;

🧮 六、三值邏輯表（Truth Table）
A	B	A = B	說明
TRUE	TRUE	TRUE	一樣
TRUE	FALSE	FALSE	不一樣
TRUE	UNKNOWN	UNKNOWN	無法判斷
FALSE	UNKNOWN	UNKNOWN	無法判斷
UNKNOWN	UNKNOWN	UNKNOWN	無法判斷
💡 七、小重點整理
重點	說明
UNKNOWN ≠ NULL	UNKNOWN 是邏輯結果，NULL 是資料值
比較中有 NULL → 結果是 UNKNOWN	除非用 IS NULL
WHERE 只會選出 TRUE	FALSE 和 UNKNOWN 都被排除
NULL = NULL 不是 TRUE	需要用 IS NULL 才能判定
🧭 八、延伸：用 NVL / COALESCE 避免 UNKNOWN

你可以用函數將 NULL 轉換成具體值：

SELECT NVL(salary, 0) FROM employees;


這樣比較運算就不會出現 UNKNOWN。

✅ 結論一句話：

UNKNOWN 是 SQL 在比較運算中，遇到 NULL 時產生的「無法判定」結果。
它不是錯誤，而是代表「不知道真或假」，
而在 WHERE 裡，它的效果等於「被忽略」。

🧩 一、什麼是 PL/SQL？

PL/SQL 全名是 Procedural Language / SQL，
中文可譯為「程序化的 SQL 語言」。

👉 它是 Oracle 對 SQL 的延伸語言，
讓你在 Oracle 資料庫中，不只能寫查詢（SELECT），
還能寫邏輯控制、條件判斷、迴圈、例外處理（Error Handling）等。

💬 簡單講：

PL/SQL = SQL + 程式語言控制結構（IF、LOOP、EXCEPTION...）

⚙️ 二、為什麼需要 PL/SQL？

原始的 SQL 是「聲明式語言（Declarative Language）」
👉 只能告訴資料庫「你要的結果是什麼」，
但不能描述「要怎麼做」。

PL/SQL 補上了這個缺口。
它讓你可以：

功能	說明
✅ 宣告變數	存資料或中間運算結果
✅ 寫條件判斷	IF...THEN...ELSE
✅ 寫迴圈	LOOP、FOR、WHILE
✅ 錯誤處理	EXCEPTION 段落
✅ 封裝邏輯	用 Procedure 或 Function
✅ 事件觸發	用 Trigger 在資料改變時自動執行程式
📦 三、PL/SQL 程式的基本結構

每個 PL/SQL 區塊（block）都有三個部分：

DECLARE
    -- 宣告區（可省略）
    v_name VARCHAR2(50);
BEGIN
    -- 主體區
    SELECT first_name INTO v_name FROM employees WHERE emp_id = 100;
    DBMS_OUTPUT.PUT_LINE('員工姓名：' || v_name);
EXCEPTION
    -- 例外處理區
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('查無資料');
END;
/


🔍 結構說明：

區塊	功能
DECLARE	宣告變數、常數、游標等
BEGIN ... END;	程式主要執行區塊
EXCEPTION	錯誤發生時要怎麼處理
🧠 四、PL/SQL 常見用途
用途	範例
📌 自動化處理	每天自動更新薪資、寄信、清除資料
📌 封裝商業邏輯	把邏輯寫成 Stored Procedure，統一被多個應用呼叫
📌 建立觸發器（Trigger）	當資料表被 INSERT/UPDATE/DELETE 時自動執行動作
📌 寫 Function	回傳計算結果給 SQL 使用
📌 批次處理（Batch Jobs）	一次處理大量資料，減少應用層負擔
🧩 五、範例比較：SQL vs PL/SQL
🧾 一般 SQL
UPDATE employees SET salary = salary * 1.1 WHERE dept_id = 10;


👉 執行單一指令，沒有條件分支、沒有錯誤處理。

🧱 PL/SQL
DECLARE
    v_rows NUMBER;
BEGIN
    UPDATE employees SET salary = salary * 1.1 WHERE dept_id = 10;
    v_rows := SQL%ROWCOUNT; -- 查更新筆數
    DBMS_OUTPUT.PUT_LINE(v_rows || ' 筆資料已更新');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('發生錯誤：' || SQLERRM);
END;
/


👉 有變數、有條件控制、有錯誤處理，像「程式」一樣運作。

🧩 六、PL/SQL 可以建立的物件類型
類型	說明
Procedure（儲存程序）	執行一段邏輯（不一定回傳值）
Function（函數）	執行後回傳一個值
Trigger（觸發器）	當事件發生（如 INSERT）自動執行
Package（套件）	一組 Procedure + Function 的集合
Anonymous Block（匿名區塊）	一次性執行、不儲存的 PL/SQL 區塊
⚙️ 七、執行位置
類型	執行位置	說明
SQL	資料庫伺服器上	單次請求
PL/SQL	伺服器端（由 Oracle Engine 執行）	多步驟邏輯一次送到資料庫執行，更快、更穩
📈 八、效能與優點
優點	說明
✅ 效能高	減少應用程式與資料庫之間的多次往返
✅ 安全性高	可以限制誰能執行某些邏輯
✅ 維護方便	可以封裝邏輯在資料庫層
✅ 九、總結一句話

🔹 PL/SQL 是 Oracle 提供的「可編程 SQL」語言，
🔹 用來在資料庫內寫流程控制、封裝商業邏輯、觸發事件。
🔹 它讓資料庫不只是存資料，更能「自己思考、自己處理」。

MySQL 也可以寫類似 PL/SQL 的程式，但它並不叫 PL/SQL。
下面我幫你完整比較一下：

🟧 什麼是 PL/SQL

全名：Procedural Language / SQL

是 Oracle 專用 的程式化 SQL 延伸語言。

它在 SQL 基礎上加入了「程式語言功能」，像：

變數宣告

條件判斷（IF / CASE）

迴圈（FOR / WHILE）

例外處理（EXCEPTION）

可建立函式（FUNCTION）與程序（PROCEDURE）

👉 換句話說，PL/SQL 讓你在 Oracle 裡寫「有邏輯、有控制流程」的 SQL。

🟩 其他資料庫的「類似語言」
資料庫系統	程式語言名稱	特性
Oracle	PL/SQL	原始版本，功能最完整。
MySQL	SQL/PSM (Stored Program)，通常就稱「Stored Procedure 語法」	支援 DECLARE、IF、LOOP、CURSOR 等功能，但語法略不同。
PostgreSQL	PL/pgSQL	模仿 PL/SQL，功能與 Oracle 類似。
Microsoft SQL Server	T-SQL (Transact-SQL)	微軟版本的擴充 SQL，有同樣的流程控制功能。

那總結，這個業界實用麼? 因為我下意識認為，這個會對資料庫產生很大的效能，而邏輯或商業運算，應盡可能在code商業邏輯裡面實現，減小database負荷
ChatGPT 說：

💯 你這個觀念其實非常成熟，幾乎是現代系統設計的主流思維。
我們來完整拆解這件事，幫你釐清 PL/SQL、商業邏輯、效能與實務應用的界線 👇

🧠 一、PL/SQL 的定位：不是用來取代程式邏輯，而是「輔助資料處理」

PL/SQL 很強大，但不代表要什麼都放進去。
它主要設計目的是：

在資料庫內部批次處理大量資料（例如上百萬筆的更新或彙整）

減少網路往返（一次送進去執行，比前端或 API 逐筆查詢快）

封裝資料邏輯（例如驗證規則、資料一致性約束）

👉 所以它的強項是「資料密集型運算」，而不是「商業邏輯或流程控制**」。

⚙️ 二、實務設計原則：程式邏輯應盡量放在應用層

在大型系統裡（ERP、金融、電商、SaaS），設計原則幾乎一致：

類型	建議實作層	理由
商業邏輯（例如折扣規則、流程判斷）	✅ 應用程式層（Java、C#、Python...）	容易版本控制、可重用、可水平擴充
資料操作（CRUD、JOIN）	✅ SQL 查詢層	資料庫本來就擅長查詢
批次資料處理、大量更新、彙整	⚙️ 可考慮 PL/SQL（或 Stored Procedure）	減少網路傳輸、效能較好
系統整體邏輯	❌ 不建議全寫在資料庫	維護困難、難以橫向擴展、DevOps 不友好
🧩 三、效能與維護角度的分析
角度	優點	缺點
PL/SQL / Stored Procedure	快速處理大資料集；減少應用層與 DB 往返	版本控制困難、Debug 不易、DB 壓力大、難擴展
應用程式邏輯	可橫向擴充、多層分工明確	若頻繁查詢小資料塊，往返次數多會拖慢效能

👉 所以「混合策略」是最理想的：

通用邏輯 → 放在應用程式

重度資料處理 → 用 PL/SQL 或批次 SQL

頻繁查詢 → 做好索引 + 快取機制（Cache）

🏢 四、實務業界的使用現況（依產業區分）
產業 / 系統	使用狀況	理由
銀行、金融	✅ 高度使用 PL/SQL	數據安全、交易邏輯封裝於資料庫內部
政府、傳產 ERP	⚙️ 中度使用	舊系統多以 Oracle 為主，重用既有程式
新創 / 雲端服務	🚫 低使用率	採用微服務架構，邏輯分散在 API 層
電商、Web App	🚫 幾乎不用	改以 Redis / API / ORM 處理邏輯
✅ 結論
面向	建議
效能	PL/SQL 適合批次型任務，不適合業務邏輯。
維護	應用層（程式）維護性遠高於 PL/SQL。
現代系統趨勢	邏輯「上移」到應用層，資料庫「專注查詢」。
何時用 PL/SQL	當你要：一次更新上百萬筆、報表彙整、排程資料清理等。

👉 一句話總結：

PL/SQL 是資料庫內的「工程機械」，不是邏輯引擎。
它在需要時非常強，但不該用來蓋整棟房子。